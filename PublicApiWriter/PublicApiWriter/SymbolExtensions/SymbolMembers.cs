using Microsoft.CodeAnalysis;
using System.Collections.Generic;
using System.Linq;

namespace PublicApiWriter.SymbolExtensions
{
    internal static class SymbolMembers
    {
        public static IEnumerable<ISymbol> GetApiAffectingMembers(this ISymbol symbol)
        {
            return GetApiAffectingMembers(symbol as INamespaceOrTypeSymbol)
                .Concat(GetApiAffectingMembers(symbol as IPropertySymbol))
                .Concat(GetApiAffectingMembers(symbol as IEventSymbol));
        }

        private static IEnumerable<ISymbol> GetApiAffectingMembers(INamespaceOrTypeSymbol symbol)
        {
            if (symbol == null || NoMembersAffectApi(symbol)) return Enumerable.Empty<ISymbol>();
            return from member in symbol.GetMembers()
                   let methodKind = (member as IMethodSymbol)?.MethodKind
                   where methodKind != MethodKind.PropertyGet && methodKind != MethodKind.PropertySet
                   where methodKind != MethodKind.EventAdd && methodKind != MethodKind.EventRemove
                   where methodKind != MethodKind.Constructor || ((ITypeSymbol) symbol).TypeKind != TypeKind.Enum
                   select member;
        }

        private static bool NoMembersAffectApi(INamespaceOrTypeSymbol symbol)
        {
            var onlyContainsAutogeneratedAlwaysIdenticalMembers = (symbol as ITypeSymbol)?.TypeKind == TypeKind.Delegate;
            return onlyContainsAutogeneratedAlwaysIdenticalMembers;
        }

        private static IEnumerable<ISymbol> GetApiAffectingMembers(IEventSymbol symbol)
        {
            return new[] { symbol?.AddMethod, symbol?.RemoveMethod, symbol?.RaiseMethod }.Where(x => x != null);
        }

        private static IEnumerable<ISymbol> GetApiAffectingMembers(IPropertySymbol symbol)
        {
            return new[] { symbol?.GetMethod, symbol?.SetMethod }.Where(x => x != null);
        }
    }
}
